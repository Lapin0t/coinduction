DECLARE PLUGIN "reification"

{


open Ltac_plugin
open Stdarg
open EConstr

(* pick an element in an hashtbl *)
let hashtbl_pick t = Hashtbl.fold (fun i x -> function None -> Some (i,x) | acc -> acc) t None

(* path to Coinduction modules *)
let lib_path = ["Coinduction"]

(* raise an error in Coq *)
let error s = Printf.kprintf (fun s -> CErrors.user_err (Pp.str s)) ("[coinduction] "^^s)

(* access to Coq constants *)
let get_const dir s = 
  lazy (EConstr.of_constr (UnivGen.constr_of_monomorphic_global (Coqlib.find_reference "coinduction.reify" dir s)))

(* make an application using a lazy value *)
let force_app f = fun x -> mkApp (Lazy.force f,x)

(* build a partial application *)
let partial_app n c ca = if n=0 then c else mkApp(c,Array.sub ca 0 n)

(* creating OCaml functions from Coq ones *)
let get_fun_1 d s = let v = get_const d s in fun x -> force_app v [|x|]
let get_fun_2 d s = let v = get_const d s in fun x y -> force_app v [|x;y|]
let get_fun_3 d s = let v = get_const d s in fun x y z -> force_app v [|x;y;z|]
let get_fun_4 d s = let v = get_const d s in fun x y z t -> force_app v [|x;y;z;t|]
let get_fun_5 d s = let v = get_const d s in fun x y z t u -> force_app v [|x;y;z;t;u|]
let get_fun_6 d s = let v = get_const d s in fun x y z t u r -> force_app v [|x;y;z;t;u;r|]
let get_fun_7 d s = let v = get_const d s in fun x y z t u r w -> force_app v [|x;y;z;t;u;r;w|]
let get_fun_8 d s = let v = get_const d s in fun x y z t u r w p -> force_app v [|x;y;z;t;u;r;w;p|]
let get_fun_9 d s = let v = get_const d s in fun x y z t u r w p q -> force_app v [|x;y;z;t;u;r;w;p;q|]
let get_fun_10 d s = let v = get_const d s in fun x y z t u r w p q q1 -> force_app v [|x;y;z;t;u;r;w;p;q;q1|]
let get_fun_11 d s = let v = get_const d s in fun x y z t u r w p q q1 q2 -> force_app v [|x;y;z;t;u;r;w;p;q;q1;q2|]
let get_fun_12 d s = let v = get_const d s in fun x y z t u r w p q q1 q2 q3 -> force_app v [|x;y;z;t;u;r;w;p;q;q1;q2;q3|]
let get_fun_13 d s = let v = get_const d s in fun x y z t u r w p q q1 q2 q3 q4 -> force_app v [|x;y;z;t;u;r;w;p;q;q1;q2;q3;q4|]
let get_fun_14 d s = let v = get_const d s in fun x y z t u r w p q q1 q2 q3 q4 q5 -> force_app v [|x;y;z;t;u;r;w;p;q;q1;q2;q3;q4;q5|]

(* Coq constants *)
module Coq = struct
  let eq_refl = get_fun_2 ["Coq"; "Init"; "Logic"] "eq_refl"
  let and_ = get_const ["Coq"; "Init"; "Logic"] "and"
  let pair = get_fun_4 ["Coq"; "Init"; "Datatypes"] "pair"
end

(* Coinduction.rel.reification Coq module *)
module Coinduction = struct
  let path  = lib_path@["tactics";"reification"]
  let hol   = get_const path "hol"
  let abs   = get_fun_2 path "abs"
  let cnj   = get_fun_2 path "cnj"
  let ft    = get_fun_2 path "fT"
  let pt    = get_fun_5 path "pT"
  let pt_   = get_const path "pT"
  let pts   = get_fun_4 path "pTs"
  let tnil  = get_fun_1 path "tnil"
  let tcons = get_fun_5 path "tcons"
  let coinduction = get_fun_5 path "coinduction"
  let accumulate  = get_fun_6 path "accumulate"
  let by_symmetry = get_fun_5 path "by_symmetry"
            
  let path     = lib_path@["lattice"]
  let body     = get_const path "body"
            
  let path     = lib_path@["coinduction"]
  let t        = get_const path "t"
  let gfp      = get_const path "gfp"
  let sym_from = get_const path "Sym_from"
end 

open Constr
open EConstr
open Proofview


(* finding the bisimulation candidate of an ongoing coinductive proof
   it must be of the shape [t ?b ?R], where [t] is the companion
   using [Tactics.generalize] is an ugly hack in order to give the value [t b R] back to Ltac
 *)
let find_candidate goal =
  let goal = Goal.print goal in
  let sigma = Tacmach.project goal in
  let rec parse e =
    match kind sigma e with
    | Prod(_,_,q) -> parse q
    | App(c,[|p;_|]) when c=Lazy.force Coq.and_ -> parse p
    | App(c,[|t;l;b;r;_;_|]) when c=Lazy.force Coinduction.body -> mkApp(c,[|t;l;b;r|])
    | _ -> error "did not recognise an ongoing proof by enhanced coinduction"
  in
  let tbr = parse (Tacmach.pf_concl goal) in
  let _,ttbr = Tacmach.pf_type_of goal tbr in
  Tactics.generalize [Coq.eq_refl ttbr tbr]
   
let apply mode goal =
  let goal = Goal.print goal in
  (* let env = Tacmach.pf_env goal in *)
  let sigma = Tacmach.project goal in
  let get_type t = 
    match kind sigma t with
    | Prod(_,a,_) -> a
    | _ -> error "coinductive object is not a relation"
  in
  let rec parse e =
    match kind sigma e with
    | Prod(i,w,q) ->
       let (c,a,slb,r,x,y,q) = parse q
       in (Coinduction.abs w (mkLambda(i,w,c)),
           a,slb,r,
           mkLambda(i,w,x),
           mkLambda(i,w,y),
           (fun l r -> mkProd(i,w,q (l+1) r)))
    | App(c,[|p1;p2|])
         when c=Lazy.force Coq.and_ ->
       let (c1,a,slb,r,x1,y1,p1) = parse p1 in
       let (c2,_,_,r',x2,y2,p2) = parse p2 in
       if r<>r' then error "only one coinductive relation is allowed";
       (Coinduction.cnj c1 c2,
        a,slb,r,
        Coq.pair (Coinduction.ft c1 a) (Coinduction.ft c2 a) x1 x2,
        Coq.pair (Coinduction.ft c1 a) (Coinduction.ft c2 a) y1 y2,
       (fun l r -> mkApp(c,[|p1 l r;p2 l r|])))
    | App(c,[|s;l;b;x;y|])      (* gfp s l b x y *)
         when mode=`Coinduction &&
                c=Lazy.force Coinduction.gfp ->
       (Lazy.force Coinduction.hol,
        get_type s,
        (s,l,b),
        mkApp(c,[|s;l;b|]),
        x,
        y,
       (fun l r -> mkApp(r l,[|x;y|])))
    | App(c,[|s;l;tb;r;x;y|])    (* body s l (t _ _ b) r x y *)
         when mode<>`Coinduction && mode <>`By_symmetry &&
                c=Lazy.force Coinduction.body ->
       (match kind sigma tb with
       | App(_,[|_;_;b|]) ->
          (Lazy.force Coinduction.hol,
           get_type s,
           (s,l,b),
           mkApp(c,[|s;l;tb;r|]),
           x,
           y,
           (fun l r -> mkApp(r l,[|x;y|])))
       | _ -> error "unrecognised construct")
    | App(c,[|s;l;b;tbr;x;y|])    (* body s l b tbr x y *)
         when mode =`By_symmetry &&
                c=Lazy.force Coinduction.body ->
          (Lazy.force Coinduction.hol,
           get_type s,
           (s,l,b),
           mkApp(c,[|s;l;b;tbr|]),
           x,
           y,
           (fun l r -> mkApp(r l,[|x;y|])))
    | _ -> error "unrecognised construct"
  in
  let rec parse_acc n e =
    match kind sigma n with
    | App(_,[|n|]) ->
       begin                    (* S n *)
         match kind sigma e with
         | Prod(i,l,q) ->
            let (l,a,_,r,x,y,l') = parse l in
            let (cs,c,u,v,_,b,r',g) = parse_acc n q in
            if r<>r' then error "only one coinductive relation is allowed";
            (Coinduction.tcons a l x y cs, c, u, v, a, b, r, mkProd(i,l' 0 (fun _ -> r),g))
         | _ -> error "unrecognised construct"
       end
    | _ ->                      (* 0 *)
       let (c,a,(s,l,b),r,x,y,e) = parse e in
       (Coinduction.tnil a, c, x, y, a, b, r,
        (* Coinduction.pt c a r x y, *)
        mkArrowR
          (e 0 (fun _ -> r))
          (e 0 (fun _ -> mkApp(Lazy.force Coinduction.body,[|s;l;b;r|]))))
  in
  match mode with
  | `Accumulate (i,rname) ->
     let (cs,c,x,y,a,b,r,p') = parse_acc i (Tacmach.pf_concl goal) in
     tclTHEN (Tactics.revert [rname])
       (tclTHEN (Tactics.apply (Coinduction.accumulate a cs c x y b))
          (tclTHEN (Tactics.introduction rname)
             (Tactics.convert_concl ~check:true p' DEFAULTcast)
       ))
     
  | `Coinduction ->
     let (c,a,(s,l,b),r,x,y,g) = parse (Tacmach.pf_concl goal) in
     let tr i j = mkApp(Lazy.force Coinduction.body,[|s;l;
                mkApp(Lazy.force Coinduction.t,[|s;l;b|]); mkRel (i+j)|]) in
     let btr j = mkApp(Lazy.force Coinduction.body,[|s;l;b;tr 2 j|]) in
     let p' = mkProd (Context.nameR (Names.Id.of_string "R"), s, (mkArrowR (g 0 (tr 1)) (g 0 btr)))  in
     tclTHEN (Tactics.apply (Coinduction.coinduction c a x y b))
       (Tactics.convert_concl ~check:true p' DEFAULTcast)
     
  | `By_symmetry ->
     let (c,a,(_,_,b),r,x,y,g) = parse (Tacmach.pf_concl goal) in
     let p = Coinduction.pt c a r x y in
     (* Feedback.msg_warning (Printer.pr_leconstr_env env sigma (Coinduction.by_symmetry c a x y b)); *)
     tclTHEN (Tactics.convert_concl~check:true p DEFAULTcast)
       (tclTHEN (Tactics.eapply (Coinduction.by_symmetry c a x y b))
       (Goal.enter (fun goal ->
            let goal = Goal.print goal in
            let sigma = Tacmach.project goal in
            match kind sigma (Tacmach.pf_concl goal) with
            | App(c,_) when c=Lazy.force Coinduction.sym_from ->
               Class_tactics.typeclasses_eauto [Class_tactics.typeclasses_db] ~depth:(Some 5)
            | App(_,[|_;_;s;_;_|]) ->
               let p' = (g 0 (fun _ -> s))  in
               Tactics.convert_concl ~check:true p' DEFAULTcast
            | _ -> tclUNIT ())))
     
}

TACTIC EXTEND coinduction_reify
| [ "apply_coinduction" ] -> { Goal.enter (apply `Coinduction) }
| [ "apply_by_symmetry" ] -> { Goal.enter (apply `By_symmetry) }
| [ "apply_accumulate" constr(i) ident(r) ] -> { Goal.enter (apply (`Accumulate(i,r))) }
| [ "find_candidate" ] -> { Goal.enter find_candidate }
END
