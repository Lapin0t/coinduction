(** an OCaml plugin to perform reification and apply the lemmas implementing enhanced coinduction.
    see end-user tactics in [tactics.v]
 *)
  

DECLARE PLUGIN "reification"

{


open Ltac_plugin
open Stdarg
open EConstr

(* pick an element in an hashtbl *)
let hashtbl_pick t = Hashtbl.fold (fun i x -> function None -> Some (i,x) | acc -> acc) t None

(* path to Coinduction modules *)
let lib_path = ["Coinduction"]

(* raise an error in Coq *)
let error s = Printf.kprintf (fun s -> CErrors.user_err (Pp.str s)) ("[coinduction] "^^s)

(* access to Coq constants *)
let get_const dir s = 
  lazy (EConstr.of_constr (UnivGen.constr_of_monomorphic_global (Coqlib.find_reference "coinduction.reify" dir s)))

(* make an application using a lazy value *)
let force_app f = fun x -> mkApp (Lazy.force f,x)

(* build a partial application *)
let partial_app n c ca = if n=0 then c else mkApp(c,Array.sub ca 0 n)

(* creating OCaml functions from Coq ones *)
let get_fun_1 d s = let v = get_const d s in fun x -> force_app v [|x|]
let get_fun_2 d s = let v = get_const d s in fun x y -> force_app v [|x;y|]
let get_fun_3 d s = let v = get_const d s in fun x y z -> force_app v [|x;y;z|]
let get_fun_4 d s = let v = get_const d s in fun x y z t -> force_app v [|x;y;z;t|]
let get_fun_5 d s = let v = get_const d s in fun x y z t u -> force_app v [|x;y;z;t;u|]
let get_fun_6 d s = let v = get_const d s in fun x y z t u r -> force_app v [|x;y;z;t;u;r|]
let get_fun_7 d s = let v = get_const d s in fun x y z t u r w -> force_app v [|x;y;z;t;u;r;w|]
let get_fun_8 d s = let v = get_const d s in fun x y z t u r w p -> force_app v [|x;y;z;t;u;r;w;p|]
let get_fun_9 d s = let v = get_const d s in fun x y z t u r w p q -> force_app v [|x;y;z;t;u;r;w;p;q|]

(* Coq constants *)
module Coq = struct
  let eq_refl = get_fun_2 ["Coq"; "Init"; "Logic"] "eq_refl"
  let and_ = get_const ["Coq"; "Init"; "Logic"] "and"
  let pair = get_fun_4 ["Coq"; "Init"; "Datatypes"] "pair"
end

(* Coinduction constants *)
module Cnd = struct
  let path  = lib_path@["tactics";"reification"]
  let hol   = get_const path "hol"
  let abs   = get_fun_2 path "abs"
  let cnj   = get_fun_2 path "cnj"
  let ft    = get_fun_2 path "fT"
  let pt_   = get_const path "pT"
  let pt    = get_fun_5 path "pT"
  let tnil  = get_fun_1 path "tnil"
  let tcons = get_fun_5 path "tcons"
  let coinduction = get_fun_5 path "coinduction"
  let accumulate  = get_fun_6 path "accumulate"
  let by_symmetry = get_fun_5 path "by_symmetry"
            
  let path     = lib_path@["lattice"]
  let body_    = get_const path "body"
  let body     = get_fun_4 path "body"
            
  let path     = lib_path@["coinduction"]
  let t        = get_fun_3 path "t"
  let gfp      = get_const path "gfp"
  let sym_from = get_const path "Sym_from"
end 

open Constr
open EConstr
open Proofview


(* finding the bisimulation candidate of an ongoing coinductive proof.
   it must be of the shape [t ?b ?R], where [t] is the companion
   it is hidden under a few quantifications/implications and conjunctions, e.g.,
   [forall x y, P x y -> t b R u v /\ forall z, t b R p q]
   using [Tactics.generalize] is an ugly hack in order to give the value [t b R] back to Ltac
   TODO: better solution?
 *)
let find_candidate goal =
  let goal = Goal.print goal in
  let sigma = Tacmach.project goal in
  let rec parse e =
    match kind sigma e with
    | Prod(_,_,q) -> parse q
    | App(c,[|p;_|]) when c=Lazy.force Coq.and_ -> parse p
    | App(c,[|t;l;b;r;_;_|]) when c=Lazy.force Cnd.body_ -> mkApp(c,[|t;l;b;r|])
    | _ -> error "did not recognise an ongoing proof by enhanced coinduction"
  in
  let tbr = parse (Tacmach.pf_concl goal) in
  let _,ttbr = Tacmach.pf_type_of goal tbr in
  Tactics.generalize [Coq.eq_refl ttbr tbr]

(* applying one of the [reification.coinduction/accumulate/by_symmetry] lemmas 
   and changing the obtained goal back into a user-friendly looking goal.
   Depending on the lemma we want to apply
   [mode] is either
   - `Coinduction
   - `Accumulate(n,rname)
   - `By_symmetry
   In the second case, [n] is the number of hypotheses to exploit (represented as a Coq constr of type [nat]), 
   and [rname] is the identifier of the current bisimulation candidate.
 *)
  
let apply mode goal =
  let goal = Goal.print goal in
  (* let env = Tacmach.pf_env goal in *)
  let sigma = Tacmach.project goal in
  
  (* when [t] is [A -> A -> Prop], returns [A] *)
  let get_type t = 
    match kind sigma t with
    | Prod(_,a,_) -> a
    | _ -> error "coinductive object is not a relation"
  in
  
  (* key function: parsing/reifying a type [e] of the shape

     [forall x y, P x y -> ?REL u v /\ forall z, ?REL p q]

     where x,y may appear in P, u, v, p, q and z may appear in p q
     and where REL is constrained by the current mode:
     - should be [gfp b] for some [b] with `Coinduction
     - should be [t b R] for some [b,R] with `Accumulate
     - should be [b (t b R)] for some [b,R] with `By_symmetry
     
     such a type [e] is interpreted as a bisimulation candidate

     returns a tuple [(a,s,l,b),r,c,x,y,q)] where
     - [a] is the type of the elements of the considered relations
     - [s] is [a->a->Prop], the type of [r]
     - [l] is the associated complete lattice 
     - [b] is the (monotone) function of the coinductive game
     - [r] is a relation on [a], the aforementioned [REL]
     - [c] has type [reification.T] and is the skeleton of the bisimulation candidate
     - [x,y] have type [reification.fT c a] and are the elements related by the bisimulation candidate
     - [q] is a function making it possible to reconstruct a nice type for the goal resulting from the application of the considered lemma.
     
     the key invariant is that [e] should be convertible to [pT c a r x y]

     in the above example,
     - [c] is [abs (fun x => abs (fun y => abs (fun _: P x y => cnj hol (abs (fun z => hol)))))]
     - [x] is [fun x y H => (u, fun z => p)]
     - [y] is [fun x y H => (v, fun z => q)]

     the OCaml type of [g] is a bit complicated: [bool -> int -> (int -> constr) -> constr]
     intuitively, [g true i REL'] should be [e] where [REL] has beend replaced by [REL']
     the integers are there to deal with de Bruijn indices:
     - in the `Coinduction case, [REL'] will involved a [mkRel] whose index depends on the depth at wich it gets replaced; [i] is used to record the current depth 
     - in the other cases, [REL'] will constructed from the context so that integers will just be ignored 
     the Boolean is only used for the `By_symmetry mode: setting it to false makes it possible to reverse all pairs in the candidate
   *)
  let rec parse e =
    match kind sigma e with
    | Prod(i,w,q) ->            (* both universal quantification and implication *)
       let (aslb,r,c,x,y,g) = parse q
       in (aslb,
           r,
           Cnd.abs w (mkLambda(i,w,c)),
           mkLambda(i,w,x),
           mkLambda(i,w,y),
           (fun v l r -> mkProd(i,w,g v (l+1) r)))
    | App(c,[|p1;p2|])          (* conjunction *)
         when c=Lazy.force Coq.and_ ->
       let (aslb,r, c1,x1,y1,g1) = parse p1 in
       let (_,   r',c2,x2,y2,g2) = parse p2 in
       let (a,_,_,_) = aslb in
       if r<>r' then error "only one coinductive relation is allowed";
       (aslb,
        r,
        Cnd.cnj c1 c2,
        Coq.pair (Cnd.ft a c1) (Cnd.ft a c2) x1 x2,
        Coq.pair (Cnd.ft a c1) (Cnd.ft a c2) y1 y2,
       (fun v l r -> mkApp(c,[|g1 v l r;g2 v l r|])))
    | App(c,[|s;l;b;x;y|])      (* gfp s l b x y *)
         when mode=`Coinduction &&
                c=Lazy.force Cnd.gfp ->
       ((get_type s,s,l,b),
        mkApp(c,[|s;l;b|]),
        Lazy.force Cnd.hol,x,y,
        (fun v l r -> mkApp(r l,if v then [|x;y|] else [|y;x|])))
    | App(c,[|s;l;tb;r;x;y|])    (* body s l (t _ _ b) r x y *)
         when mode<>`Coinduction && mode <>`By_symmetry &&
                c=Lazy.force Cnd.body_ ->
       (match kind sigma tb with
       | App(_,[|_;_;b|]) ->
          ((get_type s,s,l,b),
           mkApp(c,[|s;l;tb;r|]),
           Lazy.force Cnd.hol,x,y,
           (fun v l r -> mkApp(r l,if v then [|x;y|] else [|y;x|])))
       | _ -> error "unrecognised candidate")
    | App(c,[|s;l;b;tbr;x;y|])    (* body s l b tbr x y *)
         when mode =`By_symmetry &&
                c=Lazy.force Cnd.body_ ->
          ((get_type s,s,l,b),
           mkApp(c,[|s;l;b;tbr|]),
           Lazy.force Cnd.hol,x,y,
           (fun v l r -> mkApp(r l,if v then [|x;y|] else [|y;x|])))
    | _ -> error "unrecognised candicate"
  in

  (* extension of the above function for `Accumulate(n,rname):
     parsing/reifying a type [e] of the shape

     P1 -> ... -> Pn -> P
     
     where P and the Pi's are all of the shape described above for [parse]

     returns a tuple [(a,b,r,cs,c,u,v,g)] where
     - [a] is the type of the elements of the considered relations
     - [b] is the (monotone) function of the coinductive game
     - [r] is a relation on [a], always of the form [t b ?R]
     - [cs] has type [reification.Ts a] and contains the reified form of P1...Pn
     - [c,x,y] is the reified form of P, as above in [parse]
     - [g] is a nice type for the goal resulting from the application of the accumulation lemma, i.e.,
       P1 -> ... -> Pn -> P -> P'
       where P' is obtained from P by replacing [r] with [b r]

     the key invariant is that the starting type [e] 
     should be convertible to [pTs a cs r (pT c a r x y)]
   *)
  let rec parse_acc n e =
    match kind sigma n with
    | App(_,[|n|]) ->
       begin                    (* S n *)
         match kind sigma e with
         | Prod(i,l,q) ->
            let (_,r,d,u,v,l') = parse l in
            let (a,b,r',cs,c,x,y,g) = parse_acc n q in
            if r<>r' then error "only one coinductive relation is allowed";
            (a,b,r,Cnd.tcons a d u v cs, c, x, y, mkProd(i,l' true 0 (fun _ -> r),g))
         | _ -> error "anomaly, mismatch in hypotheses number"
       end
    | _ ->                      (* 0 *)
       let ((a,s,l,b),r,c,x,y,e') = parse e in
       (a,b,r,Cnd.tnil a, c, x, y,
        mkArrowR
          (e' true 0 (fun _ -> r))
          (e' true 0 (fun _ -> Cnd.body s l b r)))
  in

  (* main entry point *)
  match mode with
  | `Accumulate (i,rname) ->
     let (a,b,_,cs,c,x,y,g) = parse_acc i (Tacmach.pf_concl goal) in
     (* here we first revert R and re-introduce it afterwards in order to keep the same name for the candidate.
        we do so in OCaml rather than in Ltac: this makes it possible to avoid the mess with de Bruijn indices *)
     tclTHEN (Tactics.revert [rname])
       (tclTHEN (Tactics.apply (Cnd.accumulate a b cs c x y))
          (tclTHEN (Tactics.introduction rname)
             (Tactics.convert_concl ~check:true g DEFAULTcast)
       ))
     
  | `Coinduction ->
     let ((a,s,l,b),_,c,x,y,g) = parse (Tacmach.pf_concl goal) in
     (* we cannot use the same trick as above since the candidate [R] does not exist beforehand
        thus we create our own binder (whose name "R" will be overwritten by the subsequent intro in Ltac), and deal with de Bruijn indices explicitly
      *)
     let tr i j = Cnd.body s l (Cnd.t s l b) (mkRel (i+j)) in
     let btr j = Cnd.body s l b (tr 2 j) in
     let p' = mkProd (Context.nameR (Names.Id.of_string "R"), s, (mkArrowR (g true 0 (tr 1)) (g true 0 btr)))  in
     tclTHEN (Tactics.apply (Cnd.coinduction a b c x y))
       (Tactics.convert_concl ~check:true p' DEFAULTcast)
     
  | `By_symmetry ->
     let ((a,s,_,b),r,c,x,y,g) = parse (Tacmach.pf_concl goal) in
     (* several catches here...

        1. We would like to do just
        [Tactics.apply (by_symmetry a c x y b)]
        unfortunately, this does not seem to trigger typeclass resolution for instantiating the next two arguments of [by_symmetry] (the function s, and a proof of [Sym_from converse b s])
        Thus we use [eapply] instead, and we perform an explicit call to typeclass resolution for the first generated subgoal. 

        2. The unification problem seems to be more difficult here, and [eapply] fails unless we convert the goal first into its reified form.
        Using [refine (by_symmetry a c x y b _ _ _ _)] works in Ltac, but it's painful to provide a term with holes in OCaml - at least I don't know how to do it nicely.
        Whence the first two steps.

        3. after eapplying [by_symmetry], we get three subgoals and we want to
        - run typeclass resolution on the first one
        - do a change with nice types on the second and third ones 
        I don't know how to get access to those three goals separately (e.g., the tclTHENLAST tacticial has a different type than the tclTHEN I'm using here...), so that I take look at the resulting goals to recognise who is who.
      *)
     let p = Cnd.pt a r c x y in
     (* Feedback.msg_warning (Printer.pr_leconstr_env env sigma (Cnd.by_symmetry a c x y b)); *)
     tclTHEN (Tactics.convert_concl~check:true p DEFAULTcast)
       (tclTHEN (Tactics.eapply (Cnd.by_symmetry a c x y b))
       (Goal.enter (fun goal ->
            let goal = Goal.print goal in
            let sigma = Tacmach.project goal in
            match kind sigma (Tacmach.pf_concl goal) with
            (* first subgoal (typeclass resolution)*)
            | App(c,_) when c=Lazy.force Cnd.sym_from ->
               Class_tactics.typeclasses_eauto [Class_tactics.typeclasses_db] ~depth:(Some 5)
            (* third subgoal (main goal) is of the shape [pT a r' c x y] *)
            | App(c,[|_;r';_;_;_|]) when c=Lazy.force Cnd.pt_ ->
               (* here we need to look at the goal anyways, in order to discover the relation [r'] built from the function found by typeclass resolution, and use it to give a nice type *)
               let p' = (g true 0 (fun _ -> r'))  in
               Tactics.convert_concl ~check:true p' DEFAULTcast
            (* second subgoal (symmetry argument) *)               
            | _ -> 
               let p' =
                 mkProd (Context.nameR (Names.Id.of_string "R"), s,
                         mkArrowR (g true 1 mkRel) (g false 2 mkRel))
               in
               (* Feedback.msg_warning (Printer.pr_leconstr_env env sigma p'); *)
               Tactics.convert_concl ~check:true p' DEFAULTcast
       )))

}

TACTIC EXTEND coinduction_reify
| [ "apply_coinduction" ] -> { Goal.enter (apply `Coinduction) }
| [ "apply_by_symmetry" ] -> { Goal.enter (apply `By_symmetry) }
| [ "apply_accumulate" constr(i) ident(r) ] -> { Goal.enter (apply (`Accumulate(i,r))) }
| [ "find_candidate" ] -> { Goal.enter find_candidate }
END
